### 一级缓存

#### 1.需求背景
在数据库的一次会话中，有时候我们可能需要反复的执行完全相同查询语句。如果不采取一些优化的手段，那么每一次查询都会查询一次数据库，而在极短的会话周期内几乎反复查询出来的结果也是完全相同的。
与从内存获取相比，相同的数据再查询数据库的代价是很大的，如果系统的调用量较大，那么这可能造成很大的资源浪费。所以本章节结合着我们已经实现的small-mybatis框架，在一个会话周期内添加缓存操作，当会话结束 commit/close/clear 时，则进行清空缓存。

#### 2.需求分析
##### 2.1定位
数据库查询优化助手，专注于在ORM框架中实现会话级别的重复查询缓存机制
##### 2.2核心能力要求
1. 会话级缓存设计
   - 自动缓存相同SQL查询结果（包含参数匹配）
   - 缓存生命周期绑定到单个数据库会话
   - 支持缓存命中时直接返回内存结果
2. 缓存失效机制
   - 自动触发清空缓存的事件：
     • session.commit()
     • session.close()
     • session.clear()
   - 支持手动强制清除缓存
3. ORM集成要求
   - 兼容现有ORM查询执行流程
   - 在查询执行前插入缓存检查层
   - 保持事务一致性（读写分离处理）
4. 性能优化
   - 实现线程安全的缓存访问
   - 支持可配置的缓存大小限制
   - 提供缓存命中率统计接口
##### 2.3知识储备要求
1. 现有ORM框架的：
   - 会话管理实现机制
   - 查询执行链路架构
   - 事务处理流程
   
2. 数据库连接池的：
   - 生命周期管理方式
   - 现有缓存实现情况（如有）
3. 系统当前的：
   - 典型查询模式分析
   - 高频重复查询特征
   - 性能监控指标采集方式
##### 2.4约束条件
- 缓存必须保证会话隔离性
- 写操作需自动使相关缓存失效
- 内存使用不得超过预设阈值
- 缓存机制对业务代码透明

#### 3.方案设计

##### 3.1 总体架构
在现有框架的基础上，我们将在 `SqlSession` 级别实现缓存机制。缓存将存储在 `DefaultSqlSession` 实例中，并在整个会话生命周期内有效。

##### 3.2 核心组件设计

1. **Cache接口及实现**
   - `Cache`: 定义缓存的基本操作接口
   - `PerpetualCache`: 基于HashMap的简单缓存实现
   - `CacheKey`: 用于生成唯一的缓存键（结合SQL语句、参数、RowBounds等信息）

2. **SqlSession改造**
   - 在 `DefaultSqlSession` 中增加缓存实例
   - 提供缓存清理方法 `clearCache()`
   - 在 `commit()`, `rollback()`, `close()` 方法中增加清理缓存的逻辑

3. **Executor改造**
   - 在 `BaseExecutor` 中增加缓存查询和存储逻辑
   - 实现 `query()` 方法的缓存检查和更新逻辑
   - 确保 `update()` 操作后清空缓存

##### 3.3 关键流程设计

1. **查询过程**:
   ```
   query() → 
     检查缓存是否存在结果 → 
       存在：直接返回缓存结果
       不存在：执行实际查询 → 将结果存入缓存 → 返回结果
   ```

2. **更新过程**:
   ```
   update() → 
     执行实际更新 → 
     清空当前会话缓存 →
     返回影响行数
   ```

3. **缓存失效**:
   ```
   commit()/rollback()/close() → 
     清空当前会话缓存
   ```

##### 3.4 缓存键设计
缓存键将由以下要素共同组成：
- MappedStatement Id
- SQL语句
- 查询参数
- 环境ID
- RowBounds（分页信息）

##### 3.5 类图设计
```
┌─────────────┐    ┌─────────────┐
│  SqlSession │    │    Cache    │
└─────────────┘    └─────────────┘
       ▲                  ▲
       │                  │
┌──────┴──────┐    ┌──────┴──────┐
│DefaultSqlSes│    │PerpetualCach│
│    sion     │◄───│      e      │
└─────────────┘    └─────────────┘
       ▲
       │
┌──────┴──────┐    ┌─────────────┐
│   Executor  │    │  CacheKey   │
└─────────────┘    └─────────────┘
       ▲                  ▲
       │                  │
┌──────┴──────┐    ┌──────┴──────┐
│BaseExecutor │────►│ createCache│
│             │    │     Key     │
└─────────────┘    └─────────────┘
```

##### 3.6 实现步骤

1. 定义 `Cache` 接口及相关实现类
2. 实现 `CacheKey` 生成器
3. 改造 `BaseExecutor` 增加缓存逻辑
4. 在 `DefaultSqlSession` 中加入缓存管理
5. 修改会话的 `commit`、`rollback`、`close` 方法，触发缓存清理
6. 增加统计和监控接口

##### 3.7 性能与限制考量

1. **内存限制**:
   - 初期不设置硬性大小限制，依赖会话结束自动清理
   - 后续可考虑增加基于LRU的缓存淘汰策略

2. **线程安全**:
   - `SqlSession` 本身非线程安全，不支持多线程访问
   - 缓存实现应保证在单线程环境中的正确性

3. **统计指标**:
   - 缓存命中次数
   - 缓存未命中次数
   - 缓存命中率

##### 3.8 扩展性考虑

1. 后续可考虑增加缓存策略的可配置性
2. 二级缓存(全局缓存)的接口预留
3. 可插拔的缓存实现，支持不同存储介质
